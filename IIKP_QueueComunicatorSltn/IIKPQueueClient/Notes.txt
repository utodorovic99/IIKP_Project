
__________________________________________________________________________________________________________________________
# Ugljesa

// Pogledaj malloc da li mnozis br elem sa velicinom u bajtovima
// Provjeri oslobadjanja
// Promjeri leftlim i rightlim da li su ti ok
// Kasnije provjer igdje mozes i da li ti se isplati mijenjati malloc za realloc na nekim mjestima
// Provjeri optimizaciju &(some[5])
// Optimizacija u pogledu eliminisanja razmaka gdje god je to moguce
// drugi buff da obrises
// succ i fail citanje pazi na buffer
// Eliminisi nedosupne klase IP adresa
// alllocate chunk provjeravaj da ne predjes
// provjeri da li je malloc vratio null
// neke lokalne parametre za thread-ove ne pravi kao lokalne promjenjive
__________________________________________________________________________________________________________________________
OLD PACAGE PARSING (ne treba nam jer bi onda koristili pcap loop a ne preko recv)
void PrintEthernetHeader(ethernet_header* eth)
{
    printf("========> ETHERNET HEADER <========\n");
    printf("\tMAC DEST ADDR:\t%c:%c:%c:%c:%c:%c\n",
        eth->dest_address[0], eth->dest_address[1],
        eth->dest_address[2], eth->dest_address[3],
        eth->dest_address[4],eth->dest_address[5]);

    printf("\tSRC DEST ADDR:\t%c:%c:%c:%c:%c:%c\n",
        eth->src_address[0], eth->src_address[1],
        eth->src_address[2], eth->src_address[3],
        eth->src_address[4], eth->src_address[5]);

    printf("\tTYPE:\t\t%hu\n",eth->type);
    printf("===================================\n");
}

void PrintIPHeader(ip_header* iph)
{
    printf("========> INTERNET HEADER <========\n");
    printf("\tHDR LENGTH:\t%d\n",   iph->header_length);
    printf("\tVERSION:\t%d\n",    iph->version);
    printf("\tTOS:\t\t%d\n",        iph->tos);
    printf("\tLENGTH:\t\t%hu\n",    iph->length);
    printf("\tID:\t\t%hu\n",          iph->identification);
    printf("\tFRAG_FO:\t%hu\n",     iph->fragm_fo);
    printf("\tTTL:\t%d\n",          iph->ttl);
    printf("\tNEXT PROTO:\t%d\n",   iph->next_protocol);
    printf("\tCHECKSUM:\t%hu\n",    iph->checksum);
    printf("\tSRC IP:\t\t%d.%d.%d.%d\n", 
                iph->src_addr[3],   iph->src_addr[2], 
                iph->src_addr[1],   iph->src_addr[0]);
    printf("\tDST IP:\t\t%d.%d.%d.%d\n",
                iph->dst_addr[3],   iph->dst_addr[2], 
                iph->dst_addr[1],   iph->dst_addr[0]);
    printf("\tOPT PADDING:\t %u\n", iph->options_padding);
    printf("===================================\n");
}

void PrintTCPHeader(tcp_header* tcph)
{
    printf("===========> TCP HEADER <==========\n");
    printf("\tSRC PORT:\t%hu\n", tcph->src_port);
    printf("\tDST PORT:\t%hu\n", tcph->dest_port);
    printf("\tSEQ. NUM:\t%u\n", tcph->sequence_num);
    printf("\tSEQ. NUM:\t%u\n", tcph->ack_num);
    printf("\tHDR LENGTH:\t%d\n", tcph->header_length);
    printf("\tFLAGS:\t\t%d\n", tcph->flags);
    printf("\tWINDOW SIZE:\t%hu\n", tcph->windows_size);
    printf("\tCHECKSUM:\t%hu\n", tcph->checksum);
    printf("\tURG. PTR:\t%hu\n", tcph->urgent_pointer);
    printf("===================================\n");
}

char* ExtractAppData(char* msg, ethernet_header* eth, ip_header* iph, tcp_header* tcph)
{
    char* it = msg;
    if (eth != NULL)
    {
        eth->src_address[5] = (unsigned char)it[0];
        eth->src_address[4] = (unsigned char)it[1];
        eth->src_address[3] = (unsigned char)it[2];
        eth->src_address[2] = (unsigned char)it[3];
        eth->src_address[1] = (unsigned char)it[4];
        eth->src_address[0] = (unsigned char)it[5];

        eth->dest_address[5] = (unsigned char)it[6];
        eth->dest_address[4] = (unsigned char)it[7];
        eth->dest_address[3] = (unsigned char)it[8];
        eth->dest_address[2] = (unsigned char)it[9];
        eth->dest_address[1] = (unsigned char)it[10];
        eth->dest_address[0] = (unsigned char)it[11];

        eth->type            = ntohs(*((unsigned short*)(it + 12)));
    }
    it += 14;

    if (iph != NULL)
    {
        iph->header_length      = (unsigned char)(it[0] & 0xb00001111);
        iph->version            = (unsigned char)((it[0] & 0xb11110000) >> 4);
        iph->tos                = (unsigned char)it[1];
        iph->length             = ntohs(*((unsigned short*)(it + 2)));
        iph->identification     = ntohs(*((unsigned short*)(it + 4)));
        iph->fragm_fo           = ntohs(*((unsigned short*)(it + 6)));
        iph->ttl                = (unsigned char)it[7];
        iph->next_protocol      = (unsigned char)it[8];
        iph->checksum           = ntohs(*((unsigned short*)(it + 9)));

        iph->src_addr[3]        = (unsigned char)it[11];
        iph->src_addr[2]        = (unsigned char)it[12];
        iph->src_addr[1]        = (unsigned char)it[13];
        iph->src_addr[0]        = (unsigned char)it[14];

        iph->dst_addr[3]        = (unsigned char)it[15];
        iph->dst_addr[2]        = (unsigned char)it[16];
        iph->dst_addr[1]        = (unsigned char)it[17];
        iph->dst_addr[0]        = (unsigned char)it[18];

        iph->options_padding= (int)ntohs(*((unsigned short*)(it + 19)));
    }
    it += ((unsigned short)(it[0] & 0xb00001111)) * 4;
    
    if (tcph != NULL)
    {
        tcph->src_port          = ntohs(*((unsigned short*)it));
        tcph->dest_port         = ntohs(*((unsigned short*)(it+2)));
        tcph->sequence_num      = (int)ntohl(*((unsigned short*)(it + 4)));
        tcph->ack_num           = (int)ntohl(*((unsigned short*)(it + 8)));
        tcph->reserved          = (unsigned char)(it[12] & 0xb00001111);
        tcph->header_length     = (unsigned char)((it[12] & 0xb11110000) >> 4);
        tcph->flags             = (unsigned char)it[13];
        tcph->windows_size      = ntohs(*((unsigned short*)(it + 14)));
        tcph->checksum          = ntohs(*((unsigned short*)(it + 16)));
        tcph->urgent_pointer    = ntohs(*((unsigned short*)(it + 18)));
    }
    it += (unsigned char)((it[12] & 0xb11110000) >> 4) * 4;

    return it;
}
//////////////////////////////////////////////////////////////////////////////////////

Rucno punjenje strukture:
            /////////////////////////////MANUALLY LOADING NETWORK PARAMS//////////////////////////////////////////////////
            //networkParams->tcp_params = (TCPNETWORK_PARAMS*)malloc(sizeof(TCPNETWORK_PARAMS));
            //if (networkParams->tcp_params == NULL) break;
            //networkParams->tcp_params->Prepare();

            //networkParams->tcp_params->listen_socket_units = 1;
            //networkParams->tcp_params->accept_socket_units = 3;

            //networkParams->tcp_params->listen_socket_params = (SOCKETPARAMS*)malloc(1 * sizeof(SOCKETPARAMS));
            //if (networkParams->tcp_params->listen_socket_params == NULL) break;

            //networkParams->tcp_params->accept_socket_params = (SOCKETPARAMS*)malloc(3 * sizeof(SOCKETPARAMS));
            //if (networkParams->tcp_params->accept_socket_params == NULL) break;

            //unsigned addr;
            //GetApapterIP(&addr, AF_INET, true);
            //networkParams->tcp_params->listen_socket_params->address_ipv4 = addr;
            //networkParams->tcp_params->listen_socket_units = 1;
            //networkParams->tcp_params->listen_socket_params->port = 27016;
            //networkParams->tcp_params->accept_socket_params->address_ipv4 = addr;
            //networkParams->tcp_params->accept_socket_params[0].port = 27018;
            //networkParams->tcp_params->accept_socket_params[1].port = 27019;
            //networkParams->tcp_params->accept_socket_params[2].port = 27020;
            //networkParams->tcp_params->accept_socket_params[0].address_ipv4 = addr;
            //networkParams->tcp_params->accept_socket_params[1].address_ipv4 = addr;
            //networkParams->tcp_params->accept_socket_params[2].address_ipv4 = addr;
            //networkParams->tcp_params->accept_socket_contexts = (char*)(malloc(3));
            //networkParams->tcp_params->accept_socket_units = 3;
            //networkParams->tcp_params->accept_socket_contexts[0] = 1;
            //networkParams->tcp_params->accept_socket_contexts[1] = 1;
            //networkParams->tcp_params->accept_socket_contexts[2] = 1;
            //////////////////////////////////////////////////////////////////////////////////////////////////////////////
__________________________________________________________________________________________________________________________
Stara verzija sa bug-om

char cCurrentPath[FILENAME_MAX];
    if (!GetCurrentDir(cCurrentPath, sizeof(cCurrentPath)))
    {
        printf("NetCfg file missing, closing..\n");
        return -2;
    }
    else
        printf("Loading config data..\n");

    // Trenutno zbog bug-a van upotrebe
    //while (cCurrentPath[strlen(cCurrentPath) - 1] != '\\')
    //    cCurrentPath[strlen(cCurrentPath) - 1] = '\0';

    //strcat_s(cCurrentPath, "\\Release\\NetworkCfg.txt");

    //cCurrentPath[sizeof(cCurrentPath) - 1] = '\0';
    ////Append config file name

    //FILE* fptr = NULL;
    //fopen_s(&fptr, cCurrentPath, "rb");
    //if (!fptr)
    //{
    //    printf("Opening NetCfg failed, closing..\n");
    //    return -2;
    //}

    //networkParams = (NETWORKING_PARAMS*)malloc(sizeof(networkParams));
    //void* inputDataMemoryChunk = malloc(MAX_MEDIATOR_BUFF_SIZE);
    //void* usedSectionEnd = NULL;

    //NETWORKING_PARAMS tmpParams = LoadNetworkingParams(inputDataMemoryChunk, &fptr);
    NETWORKING_PARAMS* tmpParams = (NETWORKING_PARAMS*)malloc(sizeof(NETWORKING_PARAMS));

    tmpParams->tcp_params = (TCPNETWORK_PARAMS*)malloc(sizeof(TCPNETWORK_PARAMS));
    tmpParams->tcp_params->listen_socket_units = 1;
    tmpParams->tcp_params->accept_socket_units = 3;
    tmpParams->tcp_params->listen_socket_params = (SOCKETPARAMS*)malloc(1 * sizeof(SOCKETPARAMS));
    tmpParams->tcp_params->accept_socket_params = (SOCKETPARAMS*)malloc(3 * sizeof(SOCKETPARAMS));
    unsigned addr;
    GetApapterIP(&addr, AF_INET, true);
    tmpParams->tcp_params->listen_socket_params->address_ipv4 = addr;
    tmpParams->tcp_params->listen_socket_params->port = 2016;
    tmpParams->tcp_params->accept_socket_params->address_ipv4 = addr;
    tmpParams->tcp_params->accept_socket_params[0].port = 2018;
    tmpParams->tcp_params->accept_socket_params[1].port = 2019;
    tmpParams->tcp_params->accept_socket_params[2].port = 2020;
    tmpParams->tcp_params->accept_socket_params[0].address_ipv4 = addr;
    tmpParams->tcp_params->accept_socket_params[1].address_ipv4 = addr;
    tmpParams->tcp_params->accept_socket_params[2].address_ipv4 = addr;
    tmpParams->tcp_params->accept_socket_contexts = (char*)(malloc(3));
    tmpParams->tcp_params->accept_socket_contexts[0] = 1;
    tmpParams->tcp_params->accept_socket_contexts[1] = 1;
    tmpParams->tcp_params->accept_socket_contexts[2] = 1;

    // manually realloc, realloc() would mess pointers up
   // if (tmpParams.tcp_params != NULL)

    if (tmpParams->tcp_params != NULL) printf("TCP params not found");
    else
    {
        /*networkParams->tcp_params = (TCPNETWORK_PARAMS*)malloc(sizeof(TCPNETWORK_PARAMS));
        networkParams->tcp_params->listen_socket_units = tmpParams.tcp_params->listen_socket_units;
        if (tmpParams.tcp_params->listen_socket_params != NULL)
        {
            networkParams->tcp_params->listen_socket_params = (SOCKETPARAMS*)(malloc(sizeof(SOCKETPARAMS) * networkParams->tcp_params->listen_socket_units));
            memcpy(networkParams->tcp_params->listen_socket_params, tmpParams.tcp_params->listen_socket_params, (sizeof(SOCKETPARAMS) * networkParams->tcp_params->listen_socket_units));
        }

        networkParams->tcp_params->accept_socket_units = tmpParams.tcp_params->accept_socket_units;
        if (tmpParams.tcp_params->accept_socket_params != NULL)
        {
            networkParams->tcp_params->accept_socket_params = (SOCKETPARAMS*)(malloc(sizeof(SOCKETPARAMS) * networkParams->tcp_params->accept_socket_units));
            memcpy(networkParams->tcp_params->accept_socket_params, tmpParams.tcp_params->accept_socket_params, (sizeof(SOCKETPARAMS) * networkParams->tcp_params->accept_socket_units));
        }

        if (networkParams->tcp_params->accept_socket_contexts != NULL)
        {
            networkParams->tcp_params->accept_socket_contexts = (char*)(malloc(networkParams->tcp_params->accept_socket_units));
            memcpy(networkParams->tcp_params->accept_socket_contexts, tmpParams.tcp_params->accept_socket_contexts, networkParams->tcp_params->accept_socket_units);
        }*/
        networkParams = tmpParams;
        networkParams->tcp_params->Format();
    }
    if (tmpParams->tcp_params != NULL) printf("UDP params not found");
    else
    {
        // When UDP is supported
    }
    //free(inputDataMemoryChunk);

__________________________________________________________________________________________________________________________
# Nikola
__________________________________________________________________________________________________________________________